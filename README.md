# Alchemy Flux

Alchemy-Flux is the Ruby implementation of the [Alchemy Micro-Services Framework](https://github.com/LoyaltyNZ/alchemy-framework). Flux is implemented in Ruby using the [EventMachine](https://github.com/eventmachine/eventmachine) and [AMQP](https://github.com/ruby-amqp/amqp) gems, these work well with the Alchemy style of communication.

### Getting Started

To install Alchemy-Flux:

```
gem install alchemy-flux
```

To create instances of two services, `A` and `B`, and have instance `A1` call service `B`:

```ruby
require 'alchemy-flux'

service_a1 = AlchemyFlux::Service.new("A")

service_b1 = AlchemyFlux::Service.new("B") do |message|
  {'body' => "Hello #{message['body']}"}
end

service_a.start
service_b.start

# Synchronous message
response = service_a1.send_request_to_service("B", {'body' => "Alice"})
puts response['body'] # Hello Alice

# Asynchronous message
service_a1.send_request_to_service("B", {'body' => "Bob"}) do |response|
  puts response['body'] # Hello Bob
end

sleep(1) # wait for asynchronous message to complete

service_a.stop
service_b.stop
```

## Rack Implementation

Alchemy Flux comes with an implementation in Rack so that other popular frameworks like Rails or Sinatra can be used with Alchemy. The main configuration is done through environment variables:

1. `ALCHEMY_SERVICE_NAME`: the name of the service. **REQUIRED**
2. `AMQ_URI`: URL of the RabbitMQ cluster. Default is `'amqp://127.0.0.1'`,
3. `PREFETCH`: the number of messages to prefetch from RabbitMQ and handle concurrently. Default is `20`.
4. `TIMEOUT`:  the amount of milliseconds the service will wait for outgoing requests. Default is `30000`
5. `THREADPOOL_SIZE`: number of Event Machine Threads, must be greater than `PREFETCH` and should be as it represents the number of async calls and requests the service can handle.  Default is `500`
6. `ALCHEMY_RESOURCE_PATHS`: a comma separated list of resource paths that are handled by this service e.g. `'/v1/users,/v1/admins'`. Default is `''`

Then `alchemy-flux` gem into a project and run `rackup -s alchemy` to start the server with Alchemy.

For example, to run a simple Sinatra application in the Alchemy framework you will need the files:

```
# ./Gemfile
source 'https://rubygems.org'

gem 'sinatra'
gem 'alchemy-flux'
```

```
# ./config.ru
ENV['ALCHEMY_SERVICE_NAME'] = 'helloworld.service'
ENV['ALCHEMY_RESOURCE_PATHS'] = '/v1/hello'

require 'alchemy-flux'
require './service'
run Sinatra::Application
```

```
# ./service.rb
require 'sinatra'

get '/v1/hello' do
  content_type :json
  {'hello' => 'world!'}.to_json
end
```

Then run:

```
bundle install
bundle exec rackup -s alchemy
```

The service will now be listening on RabbitMQ for incoming messages, running a router and calling over HTTP, or calling directly from another service will be routed to this service.

## Documentation

The documentation for Alchemy Flux is generated by [yard](https://rubygems.org/gems/yard/versions/0.8.7.6).

## Examples

Example sending a message:

```
bundle exec ruby examples/example_1_send_message.rb
```

## Contributors

* Graham Jenson
* Tom Cully
